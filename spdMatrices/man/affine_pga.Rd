% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affine_pga.R
\name{affine_pga}
\alias{affine_pga}
\title{affine_pga}
\usage{
affine_pga(
  data,
  var.name = NULL,
  tol = 1e-04,
  nrep = 1000,
  num_comp = 5,
  symmetric = TRUE,
  cores = 1,
  scale = FALSE
)
}
\arguments{
\item{data}{List, array, or dataframe: The data you want to find the mean of.}

\item{var.name}{Character: The name of the variable containing the correlation matrices. Defaults to NULL.}

\item{tol}{Numeric: The tolerance you want to work at for the mean calculation. Defaults to 1e-8.}

\item{nrep}{Integer: The total number of iterations before you stop searching for the mean. Defaults to 1000.}

\item{num_comp}{Integer: The number of geodesic directions you want to calculate.}

\item{cores}{Integer > 0: This is set up for parallelisation on Mac through mclapply.
This will determine the number of cores to use. Defaults to 1.}

\item{symmetric:}{Logical: Should the symmetric square root be used, or the Cholesky? Defaults to TRUE.}

\item{scale:}{Logical: Should scaling be performed before PGA components are calculated. Defaults to FALSE.}
}
\value{
\itemize{
\item score: the lower dimensional representation of the data as scores.
\item loadings: The tangent vectors at the Frechet mean as matrices.  Used for interpretation.
\item sdev: The varaince along each principle geodesic.
}
}
\description{
Performs principle geodesic analysis on the cone of positive definite matrices using the affine
invariant metric.
}
\details{
This performs the tangent space approximation algorithm of PGA found in
"Riemannian Geometric Statistics in Medical Image Analysis."  This function makes use of the
prcomp function built into R.
}
\examples{
## Calculate the first tow PGA directions for the COBRE dataset.
## This will take a while.

data(cobre)

cobre_pga <- affine_pga(cobre, "cors", num_comp = 2)

# Look at the scores against each other:
plot(cobre_pga$scores, xlab = "PGA 1", ylab = "PGA 2")

# Look at the loadings
corrplot::corrplot(cobre_pga$loadings[[1]], is.corr = FALSE)
corrplot::corrplot(cobre_pga$loadings[[2]], is.corr = FALSE)
}
