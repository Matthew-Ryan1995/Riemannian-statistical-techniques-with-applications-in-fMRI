% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affine_functions.R
\name{unvec}
\alias{unvec}
\title{unvec}
\usage{
unvec(P, vec, chol = FALSE, P.sq = NULL)
}
\arguments{
\item{P}{Matrix: The base point in the manifold.}

\item{vec}{Vector: THe vecotr to translate back to the tangent space at P.  Nust be length n(n+1)/2.}

\item{chol}{Logical: Should the Cholesky square root be used?}

\item{P.sq}{Matrix: The square root of P to speed calculation. Optional.}
}
\value{
A Matrix of size n x n.
}
\description{
This is the reverse transformation of the vec function.
}
\details{
This will explicitly undo the vec function.  It will construct a symmetric matrix W such that

diag(W) = vec\link{1:n}

and

upper.tri(W) = 1/\sqrt{2} vec\link{n:n(n+1)/2}.
}
\examples{

## First grab some matrices

P <- cobre$cors[[1]]
W <- cobre$cors[[2]]

## Push W to a tangent vector using the Logarithm

W_v <- affine_map(P, W, method = "log")

## Now vectorise W_v

W_vec <- vec(P, W_v)

## Now use unvec to undo this an make sure it worked:
## Definitely back to a matrix!

(W_back <- unvec(P, W_vec))

## Check the same, up to rounding

identical(zapsmall(W_v), zapsmall(W_back))

}
