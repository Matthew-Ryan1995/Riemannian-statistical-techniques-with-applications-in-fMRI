% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affine_dist.R
\name{affine_dist}
\alias{affine_dist}
\title{affine_dist}
\usage{
affine_dist(
  df,
  var.name = NULL,
  regularise = FALSE,
  lambda = 1,
  cores = 1,
  ranks = NULL,
  sub_ids = NULL,
  tol = 1e-07
)
}
\arguments{
\item{df}{Subject array/list/df.}

\item{var.name}{String. Variable name containing correlations, df only, must be string.}

\item{regularise}{Logical. Do we want to regularise the matrices?  Default is FALSE.}

\item{lambda}{Numeric > 0.  Regularisation value.}

\item{cores}{Numeric. Can run in parallel using mclapply, number of cores to run on.  Defaults to 1.}

\item{ranks}{Numeric vector. A vector of length n containing the ranks of the matrices. Optional.}

\item{sub_ids}{Character vector.  A list of subject labels. Optional.}
}
\value{
A dist object containing the geodesic distances.
}
\description{
This is a function to calculate the geodesic distances
on the cone of positive definite symmetric matrices.  Dependent
packages are dplyr, purrr, parallel, geigen, Matrix.  See details for more information.
}
\details{
For two PSD matrices Q1 and Q2, we calculate Q = Q1^{-1/2} Q2 Q1^{-1/2}.
Then the distance d( Q1, Q2 ) = sum( log( lambda )^2 ), where lambda are the
eigenvalues of Q.  This amounts to finding the generalised eigenvalues of
Q1 and Q2.

When regularise = TRUE, we translate all matrices Q to Q + lambda x I,
where I is the identity matrix.

When regularise = FALSE, we only translate the "troublesome" matrices.  A matrix is troublesome
if it is rank deficient or almost rank deficient (eigenvalues < 1e-7).
Distances are then calculated as d( Q1, Q2 ) when Q1 and Q2 are not troublesome and
d( Q1 + lambda x I, Q2 + lambda x I ) when Q1 OR Q2 are troublesome.
}
\examples{

require(tidyverse)

#### Making some random normal data, calculating the correlations

sig <- matrix( c(1, 0.4, -0.1,
                 0.4, 1, 0.5,
                 -0.1, 0.5, 1),
               nrow = 3,
               ncol = 3 )

mu <- 1:3

df <- tibble( id = 1:171,
              obs = map(id, ~MASS::mvrnorm(n = 30, mu - mu, Sigma = sig ) ),
              cors = map( obs, cor ) )

#### Get the geodisic distance with my function

df.distances.geo <- affine_dist( x = df, var.name = "cors",
                                  regularise = FALSE, lambda = 1,  cores = 1 )


#### Transform the data into the upper triangle to let me use euclidean distance
df.Y <- df \%>\%
  transmute( id,
            upptri = map(cors, ~.x[upper.tri(.x)]),
             axes = map(1:n(), ~c("x", "y", "z"))) \%>\%
  tidyr::unnest(cols = everything()) \%>\%
  tidyr::pivot_wider( names_from = "axes", values_from = "upptri" )

#### Get Euclidean distance to see how they are different.

df.distances.euc <- dist( df.Y \%>\% select( -id ) )

}
