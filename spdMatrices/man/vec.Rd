% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/affine_functions.R
\name{vec}
\alias{vec}
\title{vec}
\usage{
vec(P, W, chol = FALSE, P.sq = NULL)
}
\arguments{
\item{P}{Matrix: The base point in the manifold.}

\item{W}{Matrix: The tangent vector to vectorise.}

\item{chol}{Logical: Should the Cholesky square root be used?}

\item{P.sq}{Matrix: The square root of P to speed calculation. Optional.}
}
\value{
A vector of length n(n+1)/2
}
\description{
This will perform the Vec function that is an explicit isometry between the tangent space
at P and Euclidean space.
}
\details{
First suppose P is the identity matrix.  Then the Vec operation is:

\if{html}{\out{<div class="sourceCode">}}\preformatted{ Vec_I(W) = c(diag(W), \\sqrt\{2\} * upper.tri(W)).
}\if{html}{\out{</div>}}

Now if P is not the identity, we translate to the identity such that

\if{html}{\out{<div class="sourceCode">}}\preformatted{ Vec_P(W) = Vec_I(P^\{-1/2\} W P^\{-1/2\}).
}\if{html}{\out{</div>}}
}
\examples{

## First grab some matrices

P <- cobre$cors[[1]]
W <- cobre$cors[[2]]

## Push W to a tangent vector using the Logarithm

W_v <- affine_map(P, W, method = "log")

## Now vectorise W_v

(W_vec <- vec(P, W_v))

## Wow, what a large vector.
## Now use unvec to undo this an make sure it worked:

W_back <- unvec(P, W_vec)

## Check the same, up to rounding

identical(zapsmall(W_v), zapsmall(W_back))

}
